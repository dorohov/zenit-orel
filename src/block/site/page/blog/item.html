<div class="{{class}} content-block">
	<div class="container {{prefix_block}}container container-content">	
		[[azbntple 
			tpl="/src/block/site/default/breadcrumb/level2.html"
			prefix_block="_oicp__" 
			prefix_bread="breadcrumb__" 
			level_1="Блог компании" 
			level_1_link="blog.html" 
			level_2="Моделирование инженерной подготовки территории" 
		]] 
		<div class="text-container">
			<div class="heading-page__hgroup">
				<h1 class="{{prefix_block}}heading heading-page"><span>{{heading_page}}</span></h1>	
			</div>
			<div class="text-block">
				<p> <img src="https://habrastorage.org/getpro/habr/post_images/a99/6ad/ec6/a996adec64d4d53a11e25ddf2cfab081.jpg" width="300" height="200"/></p>
				<p>Командная строка Unix полна сюрпризов. Например, вы&nbsp;знали, что инструмент <code>ls</code>, который чаще всего используется для получения списка файлов в&nbsp;текущем каталоге, в&nbsp;версии OS&nbsp;X&nbsp;распознаёт не&nbsp;менее <a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/ls.1.html">38&nbsp;разных флагов</a>?</p>
				<p>Я&nbsp;не&nbsp;знал, так что <a href="https://twitter.com/rtraschke/status/585933203183165441">затвитил</a> этот факт. И&nbsp;получил парочку ответов, <a href="https://twitter.com/rtraschke/status/585933203183165441">один из&nbsp;которых</a> заставил меня задуматься: действительно&nbsp;ли саму Unix нужно винить в&nbsp;этом?</p>
				<p>Насколько я&nbsp;знаю, ни&nbsp;Linux, ни&nbsp;OS&nbsp;X&nbsp;не были спроектированы в&nbsp;строгом соответствии с&nbsp;<a href="http://en.wikipedia.org/wiki/Unix_philosophy">философией Unix</a>. Будет лицемерием основывать критику «Unix» только на&nbsp;этих производных от&nbsp;Unix, которые есть у&nbsp;нас сегодня.</p>
				<p>Но&nbsp;я&nbsp;всё-таки попробую показать, как много проблем с&nbsp;интерфейсами командной строки в&nbsp;современных наследниках Unix восходят к&nbsp;корням самой Unix. В&nbsp;частности, я&nbsp;попытаюсь объяснить свой скепсис относительно идеи, что окружение командной строки Unix могло <em>когда-либо</em> поддерживать экосистему программ, каждая из&nbsp;которых хорошо выполняет одну функцию.</p>
				<p>Но&nbsp;я&nbsp;немного опережаю события. Прежде чем я&nbsp;начну говорить об&nbsp;этом, давайте более пристально посмотрим на&nbsp;команду <code>ls</code> и&nbsp;попробуем выяснить, что конкретно она делает не&nbsp;так.</p>
				<h2>Много всего, но&nbsp;слабо</h2>
				<p>Разные версии <code>ls</code> распознают разные наборы флагов, но&nbsp;в&nbsp;целом эти флаги можно распределить по&nbsp;нескольким широким категориям. Пользователи <code>ls</code> применяют флаги, чтобы:</p>
				<ul> 
					<li><strong>Определить формат выдачи</strong>. <code>−C</code> упорядочивает записи в&nbsp;аккуратную сетку; <code>−m</code> выдаёт разделённый запятыми «поток» записей; <code>−1</code> выдаёт каждую запись в&nbsp;своей собственной строке; <code>−q</code> заменяет непечатаемые символы в&nbsp;названиях файлов вопросительными знаками.</li>
					<li><strong>Отобразить дополнительную информацию о&nbsp;каждом файле</strong>. <code>−F</code> добавляет символы к&nbsp;названиям каталогов (<code>/</code>), исполняемым файлам (<code>*</code>), симлинкам (<code>@</code>) и&nbsp;другим «особым» типам файлов; <code>−s</code> выдаёт размер каждого файла рядом с&nbsp;его именем.</li>
					<li><strong>Изменить порядок файлов</strong>. <code>−r</code> для списка в&nbsp;обратном порядке; <code>−t</code> для списка файлов по&nbsp;времени последнего изменения.</li>
					<li><strong>Включить или исключить определённые файлы</strong>. <code>−a</code> включает в&nbsp;список файлы, скрытые по&nbsp;умолчанию; <code>−R</code> показывает рекурсивный список файлов в&nbsp;подкаталогах текущего каталога.</li>
				</ul>
				<p> Если опустить первую категорию флагов, то&nbsp;в&nbsp;остальных трёх есть кое-что интересное. Знатоки функционального программирования, в&nbsp;частности, могут увидеть в&nbsp;них нечто знакомое.</p>
				<p>Так и&nbsp;есть&nbsp;— каждая из&nbsp;этих трёх категорий примерно соответствует единственной общей функции высшего порядка, которая работает с&nbsp;последовательностями!</p>
				<ul> 
					<li>Флаги для <em>отображения дополнительной информации о&nbsp;каждом файле</em> можно выразить в&nbsp;терминах <code>map</code>, которая применяет заданную трансформацию на&nbsp;каждый элемент в&nbsp;последовательности независимо от&nbsp;других.</li>
					<li>Флаги для <em>изменения порядка файлов</em> можно выразить в&nbsp;терминах <code>sort</code>, которая использует заданное условие для попарного сравнения элементов и&nbsp;соответствующей сортировки.</li>
					<li>Флаги для <em>включения и&nbsp;исключения определённых файлов</em> можно выразить в&nbsp;терминах <code>filter</code>, которая проверяет каждый элемент относительно заданного утверждения и&nbsp;отклоняет&nbsp;те, что признаны неподходящими.</li>
				</ul>
				<p> <code>ls</code> кажется раздутой, потому что она <em>действительно</em> раздутая. Ряд функций высшего порядка могут взять на&nbsp;себя бóльшую часть функциональности, которая сейчас втиснута в <code>ls</code> в&nbsp;виде флагов.</p>
				<h2>Что пошло не&nbsp;так?</h2>
				<p>Идея того, что каждая программа должна вмещать в&nbsp;себе самодостаточную единицу функциональности, ни&nbsp;в&nbsp;коем случае не&nbsp;нова. Десятилетиями сторонники Unix превозносили достоинства конвейеров: «программ», созданных на&nbsp;лету соединением маленьких компонуемых фильтров друг за&nbsp;другом. В&nbsp;таком случае как можно объяснить эволюцию настолько концептуально простого инструмента как <code>ls</code> в&nbsp;сторону всё возрастающей сложности?</p>
				<div>
					<table> 
						<tbody> 
							<tr> 
								<th>Код</th>
								<th>Обозначение</th>
								<th>Описание</th>
							</tr>
							<tr> 
								<td>0</td>
								<td>INT</td>
								<td>Внешнее прерывание</td>
							</tr>
							<tr> 
								<td><nobr>1-3</nobr></td>
								<td></td>
								<td>Работа с&nbsp;виртульной памятью</td>
							</tr>
							<tr> 
								<td>4</td>
								<td>ADDRL</td>
								<td>Чтение с&nbsp;невыравненного адреса</td>
							</tr>
							<tr> 
								<td>5</td>
								<td>ADDRS</td>
								<td>Запись по&nbsp;невыравненному адресу</td>
							</tr>
							<tr> 
								<td>6</td>
								<td>IBUS</td>
								<td>Ошибка при чтении инструкций</td>
							</tr>
							<tr> 
								<td>7</td>
								<td>DBUS</td>
								<td>Ошибка на&nbsp;шине данных</td>
							</tr>
							<tr> 
								<td>8</td>
								<td>SYSCALL</td>
								<td>Системный вызов</td>
							</tr>
							<tr> 
								<td>9</td>
								<td>BKPT</td>
								<td>Брейкпоинт</td>
							</tr>
							<tr> 
								<td>10</td>
								<td>RI</td>
								<td>Зарезервированная инструкция</td>
							</tr>
							<tr> 
								<td>11</td>
								<td></td>
								<td>Ошибка сопроцессора</td>
							</tr>
							<tr> 
								<td>12</td>
								<td>OVF</td>
								<td>Арифметическое переполнение</td>
							</tr>
							<tr> 
								<td>13&nbsp;и&nbsp;выше</td>
								<td></td>
								<td>Операции с&nbsp;плавающей точкой</td>
							</tr>
						</tbody>
					</table>
				</div>
				<p> Экстремальная скупость командной строки Unix подсказывает одно возможное объяснение. Когда Unix изобрели, максимальная ширина экрана ограничивалась примерно 80&nbsp;символами, а&nbsp;использование компьютера означало сидеть перед терминалом и&nbsp;набирать команды на&nbsp;клавиатуре. В&nbsp;таком окружении имело смысл пожертвовать удобочитаемостью и&nbsp;компонуемостью, чтобы втиснуть больше информации в&nbsp;минимально возможное количество символов.</p>
				<p>В&nbsp;ту&nbsp;эпоху авторы самых популярных утилит сильно склонялись к&nbsp;тому, чтобы создавать сокращения везде, где только возможно. <code>ls</code> называется <code>ls</code> по&nbsp;той&nbsp;же самой причине, по&nbsp;которой её&nbsp;флаги представляют собой зашифрованные руны из&nbsp;одного символа вместо осмысленных слов или, не&nbsp;дай бог, целых фраз: она была разработана для небольшой группы узкоспециализированных экспертов в&nbsp;среде, где каждое нажатие клавиши, каждый символ на&nbsp;экране имел реальную и&nbsp;выразительную цену.</p>
				<p>Аналогично и&nbsp;сами флаги являются сокращениями для наиболее общих сценариев реального использования. Зачем тратить время и&nbsp;добавлять шаг фильтрации к&nbsp;конвейеру, чтобы исключить скрытые файлы из&nbsp;выдачи, если&nbsp;90% времени всё равно никто не&nbsp;хочет видеть скрытые файлы? Зачем отображать всю информацию о&nbsp;каждом файле, если&nbsp;90% времени пользователю нужны только имена?</p>
				<p>Такой образ мышления&nbsp;— что нажатия имеют высокую цену и&nbsp;что должны быть сокращения абсолютно для всего&nbsp;— определил многие из&nbsp;проблем <code>ls</code> и&nbsp;окружения командной строки Unix в&nbsp;целом.</p>
				<h3>«Универсальный интерфейс»</h3>
				<p> Но&nbsp;почему не&nbsp;написать более простую альтернативу <code>ls</code> — функцию, которая берёт произвольный каталог, или рабочий каталог по&nbsp;умолчанию, и&nbsp;возвращает список файлов из&nbsp;него, не&nbsp;обращая внимания на&nbsp;флаги? В&nbsp;конце концов, хакнуть Unix проще чем что-либо другое: если вам не&nbsp;нравится <code>ls</code>, можете заменить&nbsp;её.</p>
				<p>Отвечу на&nbsp;этот вопрос гипотезой. Представьте язык программирования, в&nbsp;котором каждая функция принимает в&nbsp;точности один аргумент (строку) и&nbsp;возвращает в&nbsp;точности один результат (другую строку).</p>
				<p>Ой, посмотрите&nbsp;— такой язык существует, и&nbsp;он&nbsp;называется шелл.</p>
				<p>Unix позволяет программам общаться друг с&nbsp;другом и&nbsp;с&nbsp;пользователем исключительно через потоки символов. Вы&nbsp;не&nbsp;можете написать функцию, которая возвращает список файлов, потому что шелл не&nbsp;знает, что такое «список», не&nbsp;знает, что такое «файлы» и&nbsp;не&nbsp;сможет сказать вам разницу между «функцией» и&nbsp;«программой», даже если от&nbsp;этого будет зависеть его жизнь.</p>
				<p>Программы не&nbsp;«принимают аргументы» и&nbsp;не&nbsp;«возвращают значения», они читают символы из <code>stdin</code> и&nbsp;печатают символы в <code>stdout</code>!</p>
				<blockquote><em>Пишите программы для обработки текстовых потоков, потому что это универсальный интерфейс.</em><br/>
					<sub>Дуглас Макилрой, «<a href="http://harmful.cat-v.org/cat-v/unix_prog_design.pdf">Проектирование программ в&nbsp;среде UNIX</a>»</sub>
				</blockquote>
				<p> Изначальные архитекторы Unix рассматривали «простоту» текстовых потоков как преимущество. Поэтому они отказывались накладывать любую структуру на&nbsp;данные, которые передаются между программами. Это решение, призванное избежать ненужной сложности, вместо этого просто перенесло излишнюю сложность дальше вниз по&nbsp;течению.</p>
				<p>Помните первую категорию флагов <code>ls</code> — те&nbsp;флаги, которые мы&nbsp;не&nbsp;могли выдать за&nbsp;сокращения стандартных трансформаций последовательности? Выходит, что это просто сокращения для неформального кодирования условных <em>списков файлов</em> в&nbsp;виде строк, которые определённые другие программы (или, в&nbsp;некоторых случаях, человеческие существа) знают, как парсить.</p>
				<p>Система неспособна предоставить абстракции, нужные пользователям. В&nbsp;ответ пользователи <a href="http://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule">изобретают их&nbsp;заново</a>, скудными, непоследовательными и&nbsp;не&nbsp;в&nbsp;тех местах. Это удручающе обычная практика.</p>
				<h3>Неприемлемый Unix</h3>
				<p>Знание истории информатики и&nbsp;ограничений, в&nbsp;которых формировались текущие ментальные модели, дарует нам своеобразную суперсилу: мы&nbsp;можем определить, когда необходимый прежде компромисс стал нелепым и&nbsp;устарел.</p>
				<p>Многие проблемы юзабилити, которые поднял Дон Норман в&nbsp;своей <a href="http://www.ceri.memphis.edu/people/smalley/ESCI7205F2009/misc_files/The_truth_about_Unix_cleaned.pdf">критике Unix</a> 1981&nbsp;года, остались практически без изменений до&nbsp;настоящего времени. В&nbsp;качестве подарка мы&nbsp;разработали графические интерфейсы, которые держат «обычных пользователей» в&nbsp;стороне от&nbsp;командной строки, но&nbsp;по-прежнему предполагается, что «серьёзные разработчики» опустятся в&nbsp;явно негуманную среду, чтобы сделать там нечто осмысленное.</p>
				<p>Вместо переоценки командной строки Unix с&nbsp;прицелом на&nbsp;улучшение юзабилити, когда современное оборудование уже не&nbsp;так ограничивает интерфейс, мы&nbsp;написали <a href="http://www.secretgeometry.com/apps/cathode/">эмуляторы терминала</a>, которые добросовестно воспроизводят ограничения середины <nobr>1970-х.</nobr> Мы&nbsp;требуем от&nbsp;новых альтернативных оболочек <a href="http://unix.stackexchange.com/questions/145522/what-does-it-mean-to-be-sh-compatible">совместимости с&nbsp;sh</a>&nbsp;и&nbsp;слепо верим, что <a href="https://www.usenix.org/legacy/event/hotos09/tech/full_papers/seltzer/seltzer.pdf">иерархические файловые системы</a>&nbsp;— оптимальный способ организации информации.</p>
				<p>Каковы шансы, что 40&nbsp;лет назад мы&nbsp;как-то натолкнулись на&nbsp;лучший возможный интерфейс взаимодействия с&nbsp;компьютером? Другими словами, каковы шансы, что наши действия сегодня имеют смысл?</p>
				<p>Даже самая ранняя версия Unix была только частной, имеющий недостатки реализацией философии Unix. Если мы&nbsp;хотим поощрить более широкое распространение <em>философии</em>, то&nbsp;не&nbsp;стóит защищать <em>реализацию</em>, преуменьшая её&nbsp;недостатки. Вместо этого нужно прямо взяться за&nbsp;эти недостатки. Строить системы, которые устраняют&nbsp;их, в&nbsp;то&nbsp;же время придерживаясь духа&nbsp;— если не&nbsp;буквы&nbsp;— принципов, на&nbsp;которых построен Unix.</p>
				<h4>Неприемлемый Unix</h4>
				<p>Знание истории информатики и&nbsp;ограничений, в&nbsp;которых формировались текущие ментальные модели, дарует нам своеобразную суперсилу: мы&nbsp;можем определить, когда необходимый прежде компромисс стал нелепым и&nbsp;устарел.</p>
				<h5>Что пошло не&nbsp;так?</h5>
				<p>Идея того, что каждая программа должна вмещать в&nbsp;себе самодостаточную единицу функциональности, ни&nbsp;в&nbsp;коем случае не&nbsp;нова. Десятилетиями сторонники Unix превозносили достоинства конвейеров: «программ», созданных на&nbsp;лету соединением маленьких компонуемых фильтров друг за&nbsp;другом. В&nbsp;таком случае как можно объяснить эволюцию настолько концептуально простого инструмента как <code>ls</code> в&nbsp;сторону всё возрастающей сложности?</p>
				<h6>Неприемлемый Unix</h6>
				<p>Знание истории информатики и&nbsp;ограничений, в&nbsp;которых формировались текущие ментальные модели, дарует нам своеобразную суперсилу: мы&nbsp;можем определить, когда необходимый прежде компромисс стал нелепым и&nbsp;устарел.</p>

			</div>
		</div>
	</div>
</div>